split.intervals[[1]][[2]]
split.intervals[[1]]
split.intervals[[1]][2,2]
# USE IF CARE ABOUT ALL OF THE VARIABLES
allsplit.fits <- list() # lists of lists of whether or not a parameter estimate fell in the sim's CI
for (i in 1:no.sim){
incl <- list()
for (j in 1:5){
incl[[j]] <- (pop.mod.coeffs[j] >= split.intervals[[i]][j,2]) & (pop.mod.coeffs[j] <= split.intervals[[i]][j,3])
}
allsplit.fits[[i]] <- incl
}
allsplit.fits
pop.mod.coeffs
split.intervals[[1]]
for (i in 1:no.sim){
incl <- list()
for (j in 1:5){
# incl[[j]] <- (pop.mod.coeffs[j] >= split.intervals[[i]][j,2]) & (pop.mod.coeffs[j] <= split.intervals[[i]][j,3])
incl[[j]] <- (pop.mod.coeffs[j] %in% seq(split.intervals[[i]][j,2],split.intervals[[i]][j,3]))
}
allsplit.fits[[i]] <- incl
}
allsplit.fits[[1]]
split.intervals
Tm
qt(0.025,df)*Tm
split.intervals <- list()
for (i in 1:no.sim){
Q <- apply(do.call(rbind,splitmods[[i]]$betas),2,mean)
B <- apply(do.call(rbind,splitmods[[i]]$betas),2,var)
W <- apply(do.call(rbind,splitmods[[i]]$se)^2,2,mean)
#Combioned standard error
Tm <- sqrt((1+1/no.imp)*B + W)
df <- (no.imp - 1) * (1 + 1/no.imp*W/B)^2
split.intervals[[i]] <- cbind(Q ,lower = Q - qt(0.975,df)*Tm, upper = Q + qt(0.975,df)*Tm)
}
wave.intervals <- list()
for (i in 1:no.sim){
Q <- apply(do.call(rbind,wavemods[[i]]$betas),2,mean)
B <- apply(do.call(rbind,wavemods[[i]]$betas),2,var)
W <- apply(do.call(rbind,wavemods[[i]]$se)^2,2,mean)
#Combioned standard error
Tm <- sqrt((1+1/no.imp)*B + W)
df <- (no.imp - 1) * (1 + 1/no.imp*W/B)^2
wave.intervals[[i]] <- cbind(Q ,lower = Q - qt(0.975,df)*Tm, upper = Q + qt(0.975,df)*Tm)
}
for (i in 1:no.sim){
incl <- list()
for (j in 1:5){
incl[[j]] <- (pop.mod.coeffs[j] >= split.intervals[[i]][j,2]) & (pop.mod.coeffs[j] <= split.intervals[[i]][j,3])
}
allsplit.fits[[i]] <- incl
}
allsplit.fits[[1]]
pop.mod.coeffs
splitmods[[1]]
pop.mod.coeffs
split.intervals[[1]]
allsplit.fits
splitmat <- matrix(allsplit.fits)
splitmat
splitmat <- as.matrix(allsplit.fits)
splitmat
splitmat <- as.matrix(unlist(allsplit.fits))
splitmat
splitmat <- matrix(unlist(allsplit.fits),5)
splitmat
allsplit.fits[[1]]
allsplit.fits[[3]]
allsplit.fits[[4]]
splitmat
split.cover <- apply(splitmat,2,mean)
split.cover
split.intervals
allwave.fits <- list() # lists of lists of whether or not a parameter estimate fell in the sim's CI
for (i in 1:no.sim){
incl <- list()
for (j in 1:5){
incl[[j]] <- (pop.mod.coeffs[j] >= wave.intervals[[i]][j,2]) & (pop.mod.coeffs[j] <= wave.intervals[[i]][j,3])
}
allwave.fits[[i]] <- incl
}
wavemat <- matrix(unlist(allwave.fits),5)
wave.cover <- apply(splitmat,2,mean)
wave.cover
wavemat
wave.intervals
split.intervals
splitmat
wavemat
TD <- function(mods){
intervals <- list()
for (i in 1:no.sim){
Q <- apply(do.call(rbind,mods[[i]]$betas),2,mean)
B <- apply(do.call(rbind,mods[[i]]$betas),2,var)
W <- apply(do.call(rbind,mods[[i]]$se)^2,2,mean)
#Combioned standard error
Tm <- sqrt((1+1/no.imp)*B + W)
df <- (no.imp - 1) * (1 + 1/no.imp*W/B)^2
intervals[[i]] <- cbind(Q ,lower = Q - qt(0.975,df)*Tm, upper = Q + qt(0.975,df)*Tm)
}
intervals
}
TD(splitmods)
split.intervals <- TD(splitmods)
wave.intervals <- TD(wavemods)
wave.intervals
coverage <- function(interval){
fits <- list() # lists of lists of whether or not a parameter estimate fell in the sim's CI
for (i in 1:no.sim){
incl <- list()
for (j in 1:5){
incl[[j]] <- (pop.mod.coeffs[j] >= intervals[[i]][j,2]) & (pop.mod.coeffs[j] <= intervals[[i]][j,3])
}
fits[[i]] <- incl
}
fit.mat <- matrix(unlist(allsplit.fits),5)
cover <- apply(splitmat,2,mean)
return( c(fit.mat,cover))
}
coverage(split.intervals)
coverage <- function(intervals){
fits <- list() # lists of lists of whether or not a parameter estimate fell in the sim's CI
for (i in 1:no.sim){
incl <- list()
for (j in 1:5){
incl[[j]] <- (pop.mod.coeffs[j] >= intervals[[i]][j,2]) & (pop.mod.coeffs[j] <= intervals[[i]][j,3])
}
fits[[i]] <- incl
}
fit.mat <- matrix(unlist(allsplit.fits),5)
cover <- apply(splitmat,2,mean)
return( c(fit.mat,cover))
}
coverage(split.intervals)
coverage <- function(intervals){
fits <- list() # lists of lists of whether or not a parameter estimate fell in the sim's CI
for (i in 1:no.sim){
incl <- list()
for (j in 1:5){
incl[[j]] <- (pop.mod.coeffs[j] >= intervals[[i]][j,2]) & (pop.mod.coeffs[j] <= intervals[[i]][j,3])
}
fits[[i]] <- incl
}
fit.mat <- matrix(unlist(allsplit.fits),5)
cover <- apply(splitmat,2,mean)
return(fit.mat,cover)
}
coverage(split.intervals)
coverage <- function(intervals){
fits <- list() # lists of lists of whether or not a parameter estimate fell in the sim's CI
for (i in 1:no.sim){
incl <- list()
for (j in 1:5){
incl[[j]] <- (pop.mod.coeffs[j] >= intervals[[i]][j,2]) & (pop.mod.coeffs[j] <= intervals[[i]][j,3])
}
fits[[i]] <- incl
}
fit.mat <- matrix(unlist(allsplit.fits),5)
cover <- apply(splitmat,2,mean)
return(list(fit.mat,cover))
}
coverage(split.intervals)
split.cover <- coverage(split.intervals)
split.intervals
split.intervals[[1]][1,1]
split.intervals[[1]][2,1]
split.intervals[[1]]
for (i in 1:no.sim){
split.ests[[i]] <- list(NA,5)
for (j in 1:no.imp){
split.ests[[i]][j] <- split.intervals[[i]][j,1]
}
}
split.ests <- list()
for (i in 1:no.sim){
split.ests[[i]] <- list(NA,5)
for (j in 1:no.imp){
split.ests[[i]][j] <- split.intervals[[i]][j,1]
}
}
split.ests
split.ests <- list()
for (i in 1:no.sim){
split.ests[[i]] <- list(NA,5)
for (j in 1:no.imp){
split.ests[[j]][i] <- split.intervals[[i]][j,1]
}
}
split.ests <- list()
for (j in 1:no.imp){
split.ests[[j]] <- list(NA,5)
for (i in 1:no.sim){
split.ests[[j]][i] <- split.intervals[[i]][j,1]
}
}
split.ests
pop.mod.coeffs
pop.mod.coeffs[1,1]
split.Qdiffs <- list()
for (j in 1:no.imp){
split.Qdiffs[[j]] <- list(NA,5)
for (i in 1:no.sim){
split.Qdiffs[[j]][i] <- unlist(split.intervals[[i]][j,1]) - unlist(pop.mod.coeffs[j,1])
}
}
split.Qdiffs
for (j in 1:no.imp){
split.Qdiffs[[j]] <- list(NA,5)
for (i in 1:no.sim){
split.Qdiffs[[j]][i] <- unlist(split.intervals[[i]][j,1]) - unlist(pop.mod.coeffs[j,1])
}
split.nums[j] <- Reduce("+",split.Qdiffs[[j]])
}
split.nums <- list()
for (j in 1:no.imp){
split.Qdiffs[[j]] <- list(NA,5)
for (i in 1:no.sim){
split.Qdiffs[[j]][i] <- unlist(split.intervals[[i]][j,1]) - unlist(pop.mod.coeffs[j,1])
}
split.nums[j] <- Reduce("+",split.Qdiffs[[j]])
}
split.nums
for (j in 1:no.imp){
split.Qdiffs[[j]] <- list(NA,5)
for (i in 1:no.sim){
split.Qdiffs[[j]][i] <- unlist(split.intervals[[i]][j,1]) - unlist(pop.mod.coeffs[j,1])
}
split.nums[j] <- Reduce("+",split.Qdiffs[[j]])
split.bias[j] <- split.nums[j]/no.sim
}
for (j in 1:no.imp){
split.Qdiffs[[j]] <- list(NA,5)
for (i in 1:no.sim){
split.Qdiffs[[j]][i] <- unlist(split.intervals[[i]][j,1]) - unlist(pop.mod.coeffs[j,1])
}
split.nums[j] <- Reduce("+",split.Qdiffs[[j]])
split.bias[j] <- unlist(split.nums[j])/no.sim
}
split.bias <- list()
split.nums <- list()
split.Qdiffs <- list()
for (j in 1:no.imp){
split.Qdiffs[[j]] <- list(NA,5)
for (i in 1:no.sim){
split.Qdiffs[[j]][i] <- unlist(split.intervals[[i]][j,1]) - unlist(pop.mod.coeffs[j,1])
}
split.nums[j] <- Reduce("+",split.Qdiffs[[j]])
split.bias[j] <- unlist(split.nums[j])/no.sim
}
split.bias
bias <- function(intervals){
results <- list()
numerator <- list()
Qdiffs <- list()
for (j in 1:no.imp){
Qdiffs[[j]] <- list(NA,5)
for (i in 1:no.sim){
Qdiffs[[j]][i] <- unlist(intervals[[i]][j,1]) - unlist(pop.mod.coeffs[j,1])
}
numerator[j] <- Reduce("+",Qdiffs[[j]])
results[j] <- unlist(numerator[j])/no.sim
}
}
bias(split.intervals)
bias <- function(intervals){
results <- list()
numerator <- list()
Qdiffs <- list()
for (j in 1:no.imp){
Qdiffs[[j]] <- list(NA,5)
for (i in 1:no.sim){
Qdiffs[[j]][i] <- unlist(intervals[[i]][j,1]) - unlist(pop.mod.coeffs[j,1])
}
numerator[j] <- Reduce("+",Qdiffs[[j]])
results[j] <- unlist(numerator[j])/no.sim
}
results
}
bias(split.intervals)
split.bias <- bias(split.intervals)
wave.bias <- bias(wave.intervals)
wave.bias
MSE <- function(intervals){
results <- list()
numerator <- list()
Qdiffs2 <- list()
for (j in 1:no.imp){
Qdiffs2[[j]] <- list(NA,5)
for (i in 1:no.sim){
Qdiffs2[[j]][i] <- (unlist(intervals[[i]][j,1]) - unlist(pop.mod.coeffs[j,1]))^2
}
numerator[j] <- Reduce("+",Qdiffs2[[j]])
results[j] <- unlist(numerator[j])/no.sim
}
results
}
mse <- function(intervals){
results <- list()
numerator <- list()
Qdiffs2 <- list()
for (j in 1:no.imp){
Qdiffs2[[j]] <- list(NA,5)
for (i in 1:no.sim){
Qdiffs2[[j]][i] <- (unlist(intervals[[i]][j,1]) - unlist(pop.mod.coeffs[j,1]))^2
}
numerator[j] <- Reduce("+",Qdiffs2[[j]])
results[j] <- unlist(numerator[j])/no.sim
}
results
}
split.mse <- mse(split.intervals)
wave.mse <- mse(wave.intervals)
split.mse
wave.mse
fmi <- function(mods){
for (i in 1:no.sim){
B <- apply(do.call(rbind,mods[[i]]$betas),2,var)
W <- apply(do.call(rbind,mods[[i]]$se)^2,2,mean)
# Combined variance
TD <- (1 + 1/no.imp)*B + W
FMI <- ((1 + (1/no.imp))*B)/TD
}
FMI
}
fmi(splitmods)
split.fmi <- fmi(splitmods)
wave.fmi <- fmi(wavemods)
wave.fmi
split.fmi
impute <- function(dat,pm){ # pass split.data
imp <- lapply(pm, function(x) {mice(x, m=no.imp)}) # loop through the split.imps in the complete function
res.data <- list()
for (i in 1:no.sim){
res.data[[i]] <- list()
for (j in 1:no.imp){
res.data[[i]][[j]] <- complete(imp[[i]],j)
}
}
}
impute <- function(pm){ # pass split.data
imp <- lapply(pm, function(x) {mice(x, m=no.imp)}) # loop through the split.imps in the complete function
res.data <- list()
for (i in 1:no.sim){
res.data[[i]] <- list()
for (j in 1:no.imp){
res.data[[i]][[j]] <- complete(imp[[i]],j)
}
}
}
impute(split.pm)
impute <- function(pm){ # pass split.data
imp <- lapply(pm, function(x) {mice(x, m=no.imp)}) # loop through the split.imps in the complete function
res.data <- list()
for (i in 1:no.sim){
res.data[[i]] <- list()
for (j in 1:no.imp){
res.data[[i]][[j]] <- complete(imp[[i]],j)
}
}
res.data
}
split.data <- impute(split.pm)
wave.data <- impute(wave.pm)
pm.mods <- function(dat){
set.seed(12345)
resmods <- list()
for (i in 1:no.sim){
resmods[i] <- list(mod.maker(dat[[i]]))
}
}
split.data
splitmods <- pm.mods(split.data)
wavemods <- pm.mods(wave.data)
splitmods
wavemods
pm.mods <- function(dat){
set.seed(12345)
resmods <- list()
for (i in 1:no.sim){
resmods[i] <- list(mod.maker(dat[[i]]))
}
resmods
}
splitmods <- pm.mods(split.data)
wavemods <- pm.mods(wave.data)
splitmods
wavemods
split.intervals <- TD(splitmods)
wave.intervals <- TD(wavemods)
split.intervals
wave.intervals
coverage <- function(intervals){
fits <- list() # lists of lists of whether or not a parameter estimate fell in the sim's CI
for (i in 1:no.sim){
incl <- list()
for (j in 1:5){
incl[[j]] <- (pop.mod.coeffs[j] >= intervals[[i]][j,2]) & (pop.mod.coeffs[j] <= intervals[[i]][j,3])
}
fits[[i]] <- incl
}
fit.mat <- matrix(unlist(allsplit.fits),5)
cover <- apply(splitmat,2,mean)
return(list(fit.mat,cover))
}
split.cover <- coverage(split.intervals)
wave.cover <- coverage(wave.intervals)
split.cover
wave.cover
bias <- function(intervals){
results <- list()
numerator <- list()
Qdiffs <- list()
for (j in 1:no.imp){
Qdiffs[[j]] <- list(NA,5)
for (i in 1:no.sim){
Qdiffs[[j]][i] <- unlist(intervals[[i]][j,1]) - unlist(pop.mod.coeffs[j,1])
}
numerator[j] <- Reduce("+",Qdiffs[[j]])
results[j] <- unlist(numerator[j])/no.sim
}
results
}
split.bias <- bias(split.intervals)
wave.bias <- bias(wave.intervals)
split.bias
wave.bias
mse <- function(intervals){
results <- list()
numerator <- list()
Qdiffs2 <- list()
for (j in 1:no.imp){
Qdiffs2[[j]] <- list(NA,5)
for (i in 1:no.sim){
Qdiffs2[[j]][i] <- (unlist(intervals[[i]][j,1]) - unlist(pop.mod.coeffs[j,1]))^2
}
numerator[j] <- Reduce("+",Qdiffs2[[j]])
results[j] <- unlist(numerator[j])/no.sim
}
results
}
split.mse <- mse(split.intervals)
wave.mse <- mse(wave.intervals)
split.mse
wave.mse
fmi <- function(mods){
for (i in 1:no.sim){
B <- apply(do.call(rbind,mods[[i]]$betas),2,var)
W <- apply(do.call(rbind,mods[[i]]$se)^2,2,mean)
# Combined variance
TD <- (1 + 1/no.imp)*B + W
FMI <- ((1 + (1/no.imp))*B)/TD
}
FMI
}
split.fmi <- fmi(splitmods)
wave.fmi <- fmi(wavemods)
split.fmi
wave.fmi
pop.mod
pop.mod.coeffs
summary(pop.mod)$coef[,1:2]
split.bias
split.cover
c(split.cover[2])
data.frame(cover=split.cover[2])
d <- data.frame(cover=split.cover[2])
d
colnames(d) <- c('Coverage','Bias','MSE','FMI')
d
d <- data.frame('Coverage=split.cover[2])
d
)
]
/
.
''
'
d <- data.frame('Coverage'=split.cover[2])
d
d <- data.frame(split.cover[2],split.bias,split.mse,split.fmi)
colnames(d) <- c('Coverage','Bias','MSE','FMI')
d
split.fmi
list(split.fmi)
unlist(split.fmi)
as.list(split.fmi)
d <- data.frame(split.cover[2],split.bias,split.mse,as.list(split.fmi))
colnames(d) <- c('Coverage','Bias','MSE','FMI')
d
split.mse
split.bias
as.list(split.fmi)
unlist(as.list(split.fmi))
d <- data.frame(split.cover[2],split.bias,split.mse)
d
d <- data.frame(split.cover[2],split.bias,split.mse)
d
cbind((split.cover[2],split.bias,split.mse))
cbind(split.cover[2],split.bias,split.mse)
cbind(split.bias,split.mse)
d <- data.frame(split.cover[2],cbind(split.bias,split.mse))
d
d <- data.frame(split.cover[2],cbind(split.bias,split.mse),split.fmi)
d
colnames(d) <- c('Coverage','Bias','MSE','FMI')
d
split.table <- data.frame(split.cover[2],cbind(split.bias,split.mse),split.fmi)
wave.table <- data.frame(wave.cover[2],cbind(wave.bias,wave.mse),wave.fmi)
colnames(wave.table) <- c('Coverage','Bias','MSE','FMI')
wave.table
