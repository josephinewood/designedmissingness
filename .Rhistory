for (j in 1:no.imp){
for (k in 1:no.pid){
split.pids[i][j][k] <- list(split.pids[i][j][k],splitmods[[i]][[j]][[1]][[1]][k]) # take the intercept and append it to the list
}
}
}
split.pids
splitmods[[1]][[1]][[1]][[1]][1]
splitmods[[1]][[1]][[1]][[1]][2]
for (i in 1:no.sim){
for (j in 1:no.imp){
for (k in 1:no.pid){
split.pids[i][j][k] <- c(split.pids[i][j][k],splitmods[[i]][[j]][[1]][[1]][k]) # take the intercept and append it to the list
}
}
}
warnings()
splitmods[i][j][1][1][1]
splitmods[1][1][1][1][1]
splitmods[[1]][[1]][[1]][[1]][1]
for (i in 1:no.sim){
for (j in 1:no.imp){
for (k in 1:no.pid){
split.pids[i][j][k] <- splitmods[[i]][[j]][[1]][[1]][k] # take the intercept and append it to the list
}
}
}
split.pids
for (i in 1:no.sim){
for (j in 1:no.imp){
for (k in 1:no.pid){
split.pids[i][j][[k]] <- splitmods[[i]][[j]][[1]][[1]][k] # take the intercept and append it to the list
}
}
}
split.pids
for (i in 1:no.sim){
}
for (i in 1:no.sim){
for (j in 1:no.imp){
for (k in 1:no.pid){
split.pids[i][j][[k]] <- list(split.pids[i][j][[k]],splitmods[[i]][[j]][[1]][[1]][k]) # take the intercept and append it to the list
}
}
}
for (i in 1:no.sim){
for (j in 1:no.imp){
for (k in 1:no.pid){
split.pids[i][j][k] <- list(split.pids[i][j][k],splitmods[[i]][[j]][[1]][[1]][k]) # take the intercept and append it to the list
}
}
}
split.pids
for (i in 1:no.sim){
for (j in 1:no.imp){
for (k in 1:no.pid){
split.pids[[i]][j][k] <- list(split.pids[i][j][k],splitmods[[i]][[j]][[1]][[1]][k]) # take the intercept and append it to the list
}
}
}
split.pids
for (i in 1:no.sim){
for (j in 1:no.imp){
for (k in 1:no.pid){
split.pids[[i]][j][k] <- list(split.pids[[i]][j][k],splitmods[[i]][[j]][[1]][[1]][k]) # take the intercept and append it to the list
}
}
}
split.pids
for (i in 1:no.sim){
for (j in 1:no.imp){
for (k in 1:no.pid){
split.pids[[i]][[j]][k] <- list(split.pids[[i]][[j]][k],splitmods[[i]][[j]][[1]][[1]][k]) # take the intercept and append it to the list
}
}
}
split.pids
for (i in 1:no.sim){
for (j in 1:no.imp){
for (k in 1:no.pid){
split.pids[[i]][[j]][[k]] <- list(split.pids[[i]][[j]][[k]],splitmods[[i]][[j]][[1]][[1]][k]) # take the intercept and append it to the list
}
}
}
split.pids
for (i in 1:no.sim){
for (j in 1:no.imp){
for (k in 1:no.pid){
split.pids[[i]][[j]][[k]] <- c(split.pids[[i]][[j]][[k]],splitmods[[i]][[j]][[1]][[1]][k]) # take the intercept and append it to the list
}
}
}
split.pids
splitmods[[1]][[1]][[1]][[1]][1]
for (k in 1:no.pid){
for (j in 1:no.imp){
for (i in 1:no.sim){
split.pids[[k]][j] <- splitmods[[i]][[j]][[1]][[1]][k]
}
}
}
for (k in 1:no.pid){
for (j in 1:no.imp){
for (i in 1:no.sim){
split.pids[k][j] <- splitmods[[i]][[j]][[1]][[1]][k]
}
}
}
split.pids
for (k in 1:no.pid){
for (j in 1:no.imp){
for (i in 1:no.sim){
split.pids[k][i][j] <- splitmods[[i]][[j]][[1]][[1]][k]
}
}
}
split.pids
for (k in 1:no.pid){
for (i in 1:no.sim){
for (j in 1:no.imp){
split.pids[k][i][j] <- splitmods[[i]][[j]][[1]][[1]][k]
}
}
}
split.pids
for (k in 1:no.pid){
for (i in 1:no.sim){
for (j in 1:no.imp){
split.pids[[k]][[i]][j] <- splitmods[[i]][[j]][[1]][[1]][k]
}
}
}
for (k in 1:no.pid){
for (i in 1:no.sim){
for (j in 1:no.imp){
split.pids[[k]][i][j] <- splitmods[[i]][[j]][[1]][[1]][k]
}
}
}
split.pids
split.pids <- list()
for (k in 1:no.pid){
for (i in 1:no.sim){
for (j in 1:no.imp){
split.pids[[k]][i][j] <- splitmods[[i]][[j]][[1]][[1]][k]
}
}
}
for (k in 1:no.pid){
for (i in 1:no.sim){
for (j in 1:no.imp){
split.pids[k][i][j] <- splitmods[[i]][[j]][[1]][[1]][k]
}
}
}
split.pids
for (k in 1:no.pid){
for (i in 1:no.sim){
for (j in 1:no.imp){
split.pids[[k]][i][j] <- splitmods[[i]][[j]][[1]][[1]][k]
}
}
}
split.pids
split.pids <- list()
for (k in 1:no.pid){
for (i in 1:no.sim){
for (j in 1:no.imp){
split.pids[[k]][[i]][j] <- splitmods[[i]][[j]][[1]][[1]][k] # same subscripting thing
}
}
}
for (k in 1:no.pid){
for (i in 1:no.sim){
for (j in 1:no.imp){
split.pids[k][i][j] <- splitmods[[i]][[j]][[1]][[1]][k] # same subscripting thing
}
}
}
for (k in 1:no.pid){
for (i in 1:no.sim){
for (j in 1:no.imp){
split.pids[[k]][i][j] <- splitmods[[i]][[j]][[1]][[1]][k] # same subscripting thing
}
}
}
warnings()
for (k in 1:no.pid){
for (i in 1:no.sim){
for (j in 1:no.imp){
wave.pids[[k]][i][j] <- wavemods[[i]][[j]][[1]][[1]][k] # same subscripting thing and no. of items not multiple of replacement length warning
}
}
}
for (k in 1:no.pid){
for (i in 1:no.sim){
for (j in 1:no.imp){
wave.pids[k][i][j] <- wavemods[[i]][[j]][[1]][[1]][k] # same subscripting thing and no. of items not multiple of replacement length warning
}
}
}
for (k in 1:no.pid){
for (i in 1:no.sim){
for (j in 1:no.imp){
wave.pids[[k]][i][j] <- wavemods[[i]][[j]][[1]][[1]][k] # same subscripting thing and no. of items not multiple of replacement length warning
}
}
}
wave.pids
for (k in 1:no.pid){
split.pid.means[k] <- mean(split.pids[[k]])
}
split.pid.means <- list()
wave.pid.means <- list()
for (k in 1:no.pid){
split.pid.means[k] <- mean(split.pids[[k]])
}
split.pid.means
for (k in 1:no.pid){
wave.pid.means[k] <- mean(wave.pids[[k]])
}
wave.pid.means
for (i in 1:no.sim){
sim.mods[i] <- glmer(MissedDose ~ DrinkYN*Day + Q1 + Q2 + Q3 + Q4 + Q5 + Q6 + Q7 + (1|PID), data = sim.data[[i]], family=binomial(link=logit))
}
sim.mods <- list()
for (i in 1:no.sim){
sim.mods[i] <- glmer(MissedDose ~ DrinkYN*Day + Q1 + Q2 + Q3 + Q4 + Q5 + Q6 + Q7 + (1|PID), data = sim.data[[i]], family=binomial(link=logit))
}
sim.mods
for (i in 1:no.sim){
sim.mods[i] <- glmer(MissedDose ~ DrinkYN*Day + Q1 + Q2 + Q3 + Q4 + Q5 + Q6 + Q7 + (1|PID), data = sim.data[[i]], family=binomial(link=logit))
sim.mod.coeffs[i] <- coef(sim.mods[i])
}
sim.mod.coeffs <- list()
for (i in 1:no.sim){
sim.mods[i] <- glmer(MissedDose ~ DrinkYN*Day + Q1 + Q2 + Q3 + Q4 + Q5 + Q6 + Q7 + (1|PID), data = sim.data[[i]], family=binomial(link=logit))
sim.mod.coeffs[i] <- coef(sim.mods[i])
}
sim.mod.coeffs
sim.mod.coeffs[1]
for (i in 1:no.sim){
sim.mods[i] <- glmer(MissedDose ~ DrinkYN*Day + Q1 + Q2 + Q3 + Q4 + Q5 + Q6 + Q7 + (1|PID), data = sim.data[[i]], family=binomial(link=logit))
sim.mod.coeffs[[i]] <- coef(sim.mods[i])
}
sim.mod.coeffs[1]
str(sim.mod[1])
str(sim.mods[1])
i<-1
sim.mod.coeffs[[i]] <- sim.mods[i]@beta
sim.mod.coeffs[[i]] <- sim.mods[[i]]@beta
sim.mod.coeffs[[i]]
for (i in 1:no.sim){
sim.mods[i] <- glmer(MissedDose ~ DrinkYN*Day + Q1 + Q2 + Q3 + Q4 + Q5 + Q6 + Q7 + (1|PID), data = sim.data[[i]], family=binomial(link=logit))
sim.mod.coeffs[[i]] <- sim.mods[[i]]@beta
}
sim.mod.coeffs
sim.mod[1]
sim.mods[1]
coef(sim.mods[[1]])
for (i in 1:no.sim){
sim.mods[i] <- glmer(MissedDose ~ DrinkYN*Day + Q1 + Q2 + Q3 + Q4 + Q5 + Q6 + Q7 + (1|PID), data = sim.data[[i]], family=binomial(link=logit))
sim.mod.coeffs[[i]] <- coef(sim.mods[[i]])
}
sim.mod.coeffs
sim.pids <- list()
for (i in 1:no.sim){
split.coeff.means[[i]] <- colMeans(splitmods[[i]][[1]]) # using split.coeff.means[[i]] throws an error about the subscript being out of bounds, but if run with split.coeff.means[i] and THEN double brackets, it works???
}
for (i in 1:no.sim){
for (j in 1:no.imp){
split.coeff.means[[i]][j] <- colMeans(splitmods[[i]][[j]][[1]]) # using split.coeff.means[[i]] throws an error about the subscript being out of bounds, but if run with split.coeff.means[i] and THEN double brackets, it works???
}
}
no.pid <- 60
sim.mods.coeffs[[i]][[1]][[1]][1]
sim.mod.coeffs[[i]][[1]][[1]][1]
sim.pids <- list()
for (k in 1:no.pid){
for (i in 1:no.sim){
split.pids[[k]][i] <- sim.mod.coeffs[[i]][[1]][[1]][k] # same subscripting thing and no. of items not multiple of replacement length warning
}
}
sim.pids
for (k in 1:no.pid){
for (i in 1:no.sim){
split.pids[[k]][[i]] <- sim.mod.coeffs[[i]][[1]][[1]][k] # same subscripting thing and no. of items not multiple of replacement length warning
}
}
sim.pids
sim.pids[[k]][[i]] <- sim.mod.coeffs[[i]][[1]][[1]][k] # same subscripting thing and no. of items not multiple of replacement length warning
for (k in 1:no.pid){
for (i in 1:no.sim){
sim.pids[k][[i]] <- sim.mod.coeffs[[i]][[1]][[1]][k] # same subscripting thing and no. of items not multiple of replacement length warning
}
}
sim.pids
for (k in 1:no.pid){
for (i in 1:no.sim){
sim.pids[[k]][[i]] <- sim.mod.coeffs[[i]][[1]][[1]][k] # same subscripting thing and no. of items not multiple of replacement length warning
}
}
sim.pids
for (k in 1:no.pid){
for (i in 1:no.sim){
for (j in 1:no.imp){
split.pids[[k]][i][j] <- splitmods[[i]][[j]][[1]][[1]][k] # same subscripting thing and no. of items not multiple of replacement length warning
}
}
}
for (k in 1:no.pid){
sim.pid.means[k] <- mean(sim.pids[[k]])   # means for wave and split are very similar but not the same!
}
sim.pid.means <- list()
for (k in 1:no.pid){
sim.pid.means[k] <- mean(sim.pids[[k]])   # means for wave and split are very similar but not the same!
}
sim.pid.means
split.pid.means
split.coeff.means
sim.mod.coeffs
coef(sim.mods[[i]])[[1]]
coef(sim.mods[[i]])[[1]][1]
sim.mod.intercepts <- list()
sim.mod.coeffs <- list()
for (i in 1:no.sim){
sim.mods[i] <- glmer(MissedDose ~ DrinkYN*Day + Q1 + Q2 + Q3 + Q4 + Q5 + Q6 + Q7 + (1|PID), data = sim.data[[i]], family=binomial(link=logit))
sim.mod.intercepts[[i]] <- coef(sim.mods[[i]])[[1]][1]
sim.mod.coeffs[[i]] <- colMean(coef(sim.mods[[i]])[[1]][2:])
}
for (i in 1:no.sim){
sim.mods[i] <- glmer(MissedDose ~ DrinkYN*Day + Q1 + Q2 + Q3 + Q4 + Q5 + Q6 + Q7 + (1|PID), data = sim.data[[i]], family=binomial(link=logit))
sim.mod.intercepts[[i]] <- coef(sim.mods[[i]])[[1]][1]
sim.mod.coeffs[[i]] <- colMean(coef(sim.mods[[i]])[[1]][,2:])
}
for (i in 1:no.sim){
sim.mods[i] <- glmer(MissedDose ~ DrinkYN*Day + Q1 + Q2 + Q3 + Q4 + Q5 + Q6 + Q7 + (1|PID), data = sim.data[[i]], family=binomial(link=logit))
sim.mod.intercepts[[i]] <- coef(sim.mods[[i]])[[1]][1]
sim.mod.coeffs[[i]] <- colMean(coef(sim.mods[[i]])[[1]][2:11])
}
for (i in 1:no.sim){
sim.mods[i] <- glmer(MissedDose ~ DrinkYN*Day + Q1 + Q2 + Q3 + Q4 + Q5 + Q6 + Q7 + (1|PID), data = sim.data[[i]], family=binomial(link=logit))
sim.mod.intercepts[[i]] <- coef(sim.mods[[i]])[[1]][1]
sim.mod.coeffs[[i]] <- colMeans(coef(sim.mods[[i]])[[1]][2:11])
}
sim.mod.coeffs
split.coeff.means
for (i in 1:no.sim){
sim.mods[i] <- glmer(MissedDose ~ DrinkYN*Day + Q1 + Q2 + Q3 + Q4 + Q5 + Q6 + Q7 + (1|PID), data = sim.data[[i]], family=binomial(link=logit))
sim.mod.intercepts[[i]] <- coef(sim.mods[[i]])[[1]][1]
sim.mod.coeffs[[i]] <- colMeans(sim.mods[[i]]@beta[2:11])
}
splitmods[[1]][[1]][[1]]
for (i in 1:no.sim){
for (j in 1:no.imp){
split.coeff.means[[i]][j] <- colMeans(splitmods[[i]][[j]][[1]][2:11]) # using split.coeff.means[[i]] throws an error about the subscript being out of bounds, but if run with split.coeff.means[i] and THEN double brackets, it works???
}
}
split.coeff.means
splitmods[[1]][[1]][[1]][2:11]
typeof(splitmods[[1]][[1]][[1]][2:11])
?colMeans
for (i in 1:no.sim){
for (j in 1:no.imp){
split.coeff.means[[i]][[j]] <- colMeans(splitmods[[i]][[j]][[1]][2:11]) # using split.coeff.means[[i]] throws an error about the subscript being out of bounds, but if run with split.coeff.means[i] and THEN double brackets, it works???
}
}
for (i in 1:no.sim){
for (j in 1:no.imp){
split.coeff.means[[i]][j] <- colMeans(splitmods[[i]][[j]][[1]][2:11]) # using split.coeff.means[[i]] throws an error about the subscript being out of bounds, but if run with split.coeff.means[i] and THEN double brackets, it works???
}
}
splitmods[[1]][1][[1]][2:11]
split.coeff.means
for (i in 1:no.sim){
for (j in 1:no.imp){
split.coeff.means[[i]][j] <- list(colMeans(splitmods[[i]][[j]][[1]][2:11])) # using split.coeff.means[[i]] throws an error about the subscript being out of bounds, but if run with split.coeff.means[i] and THEN double brackets, it works???
}
}
split.coeff.means
for (i in 1:no.sim){
for (j in 1:no.imp){
wave.coeff.means[[i]][j] <- list(colMeans(wavemods[[i]][[j]][[1]][2:11])) # same here
}
}
wave.coeff.means
split.pid.means
wave.pid.means
sim.pid.means
Daily <- read.csv('~/GitHub/designedmissingness/Daily with Tox.csv')
# Retain desired variables
names(Daily)[1] <- c('PID')
Daily <- Daily[,c('PID', 'Day', 'Q1', 'Q2', 'Q3', 'Q4', 'Q5', 'Q6', 'Q7'
,'MissedDose'
, 'ZEduc', 'ZIncom45', 'Gender', 'Age', 'ZAlcTox'
,'ZCESDFU', 'ZAUDIT', 'DrinkYN')]
# Impute missing values in new dataset, 'comp'...Daily has 4.74% missing (sum(is.na(Daily))/prod(dim(Daily)))
comp <- complete(mice(Daily, m=1, seed=817236),1)
# Convert Age to data type 'double'
comp$Age <- as.numeric(comp$Age)
# Shift days back 1 day
comp$Day <- comp$Day-1
# Remove the Daily dataset from the environment
rm(Daily)
#comp$Age <- as.numeric(scale(comp$Age)) # why???
comp$Q1 <- as.factor(comp$Q1)
comp$Q2 <- as.factor(comp$Q2)
comp$Q3 <- as.factor(comp$Q3)
comp$Q4 <- as.factor(comp$Q4)
comp$Q5 <- as.factor(comp$Q5)
comp$Q6 <- as.factor(comp$Q6)
comp$Q7 <- as.integer(comp$Q7)
comp$DrinkYN <- as.factor(comp$DrinkYN)
comp$MissedDose <- as.factor(comp$MissedDose)
comp$Gender <- as.factor(comp$Gender)
pop.mod <- glmer(MissedDose ~ DrinkYN*Day + Q1 + Q2 + Q3 + Q4 + Q5 + Q6 + Q7 + (1|PID), data = comp, family=binomial(link=logit))
pop.mod@beta
coef(pop.mod)
coef(pop.mod)[[1]][[1]][2:11]
sim.mod.intercepts
pop.pids <- list(coef(pop.mod)[[1]][[1]][1])
pop.pids
pop.pids <- list(coef(pop.mod)[[1]][[1]][[1]])
pop.pids <- list(coef(pop.mod)[[1]][[1]][[1]])
pop.pids
sim.mod.coeffs
sim.pids
for (k in 1:no.pid){
pop.pids[[k]]<- coef(pop.mod)[[1]][[1]][[k]] # subscripting thing and no. of items not multiple of replacement length warning
}
pop.pids[[k]]<- coef(pop.mod)[[1]][[1]][k] # subscripting thing and no. of items not multiple of replacement length warning
for (k in 1:no.pid){
pop.pids[[k]]<- coef(pop.mod)[[1]][[1]][k] # subscripting thing and no. of items not multiple of replacement length warning
}
pop.pids
coef(pop.mod)[[1]][[1]][[1]]
coef(pop.mod)[[1]][[1]][1]
coef(pop.mod)[[1]][[1]]
length(coef(pop.mod)[[1]][[1]])
comp
unique(comp$PID)
length(sim.pids)
length(split.pids)
coef(pop.mod)[[1]][[1]][60]
length(coef(pop.mod)[[1]][[1]])
split.pids
sim.pids
split.pid.means
sim.split.pid.means <- sim.pid.means - split.pid.means
for (k in 1:no.pid){
sim.split.pid.means[k] <- sim.pid.means[k]-split.pid.means[k]
}
?diff
?subtract
typeof(sim.pid.means)
typeof(sim.pid.means[1])
typeof(sim.pid.means[[1]])
for (k in 1:no.pid){
sim.split.pid.means[k] <- sim.pid.means[[k]]-split.pid.means[[k]]
}
sim.split.pid.means <- list()
for (k in 1:no.pid){
sim.split.pid.means[k] <- sim.pid.means[[k]]-split.pid.means[[k]]
}
sim.split.pid.means
pid.means <- cbind(sim.pid.means,split.pid.means,wave.pid.means)
pid.means
split.pids
splitmods[[1]]
for (k in 1:no.pid){
for (i in 1:no.sim){
for (j in 1:no.imp){
split.pids[[k]][[i]][j] <- splitmods[[i]][[j]][[1]][[1]][k] # same subscripting thing and no. of items not multiple of replacement length warning
}
}
}
for (k in 1:no.pid){
for (i in 1:no.sim){
for (j in 1:no.imp){
split.pids[[k]][[i]][[j]] <- splitmods[[i]][[j]][[1]][[1]][k] # same subscripting thing and no. of items not multiple of replacement length warning
}
}
}
for (k in 1:no.pid){
for (i in 1:no.sim){
for (j in 1:no.imp){
split.pids[[k]][i][j] <- splitmods[[i]][[j]][[1]][[1]][k] # same subscripting thing and no. of items not multiple of replacement length warning
}
}
}
for (k in 1:no.pid){
for (i in 1:no.sim){
for (j in 1:no.imp){
split.pids[[k]][[i]][j] <- splitmods[[i]][[j]][[1]][[1]][k] # same subscripting thing and no. of items not multiple of replacement length warning...results in 5 intercepts per PID, not 25 as expected, I think it takes the first intercept for each set of 5 imputation sets
}
}
}
for (k in 1:no.pid){
for (i in 1:no.sim){
for (j in 1:no.imp){
split.pids[[k]][i][j] <- splitmods[[i]][[j]][[1]][[1]][k] # same subscripting thing and no. of items not multiple of replacement length warning...results in 5 intercepts per PID, not 25 as expected, I think it takes the first intercept for each set of 5 imputation sets
}
}
}
coeff.means <- cbind(sim.mod.coeffs,split.coeff.means,wave.coeff.means)
coeff.means
split.coeff.means
sim.mods[1]
sim.mod.coeffs
summary(sim.mods[1])
summary(sim.mods[[1]])
summary(sim.mods[[1]])$coefficients[1,2]
