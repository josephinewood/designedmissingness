set.seed(12345)
splitmods <- list()
for (i in 1:no.sim){
splitmods[i] <- list(mod.maker(split.data[[i]])) # fails to converge
}
set.seed(12345)
wavemods <- list()
for (i in 1:no.sim){
wavemods[i] <- list(mod.maker(wave.data[[i]])) # also fails to converge
}
splitmods
summary(model)$coef[,1:2]
mod.maker <- function(dat){ # passing split.data[[i]]
mods <- list()
for (j in 1:length(dat)){
df <- data.frame(split.data[[j]])
model <- glmer(MissedDose ~ Q7 + ZAlcTox + Day + Q7*Day + (1|PID), data = df, family=binomial(link=logit))
mods[[j]] <- summary(model)$coef[,1:2] # only take the coefficients of the variables, not the intercept
}
mods
}
set.seed(12345)
splitmods <- list()
for (i in 1:no.sim){
splitmods[i] <- list(mod.maker(split.data[[i]])) # fails to converge
}
set.seed(12345)
wavemods <- list()
for (i in 1:no.sim){
wavemods[i] <- list(mod.maker(wave.data[[i]])) # also fails to converge
}
splitmods
# pop.pids <- list()
pop.mod.coeffs <- summary(pop.mod)$coef[,1:2] # if glmer object: take the first row of coefficients, excluding the intercept, the betas are the same for each PID but the intercept varies.
pop.mod.coeffs
for (i in 1:no.sim){
sim.mods[[i]] <- glmer(MissedDose ~ Q7 + ZAlcTox + Day + Q7*Day + (1|PID), data = as.data.frame(sim.data[i]), family=binomial(link=logit))
#sim.mod.intercepts[[i]] <- coef(sim.mods[[i]])[[1]][1]
sim.mod.coeffs[[i]] <- summary(sim.mods[[i]])$coef[,1:2] # take the first row and only the last 4 columns to get coefficients for everything but the intercepts
}
sim.mods
sim.mod.coeffs
splitmods
# Step 4 - Calculate mean parameter estimates for both methods
# compare means of coefficents overall and then find means of each person's intercept and compare those to original???
split.coeff.means <- list()
wave.coeff.means <- list()
for (i in 1:no.sim){
for (j in 1:no.imp){
split.coeff.means[[i]] <- list(colMeans(as.data.frame(do.call(rbind, splitmods[[i]])))) # using split.coeff.means[[i]] throws an error about the subscript being out of bounds, but if run with split.coeff.means[i] and THEN double brackets, it works???
}
}
split.coeff.means
for (i in 1:no.sim){
for (j in 1:no.imp){
wave.coeff.means[[i]] <- list(colMeans(as.data.frame(do.call(rbind, wavemods[[i]])))) # same here
}
}
wave.coeff.means
splitmods[[1]]
mod.maker <- function(dat){ # passing split.data[[i]]
modbetas <- list()
modse <- list()
for (j in 1:length(dat)){
df <- data.frame(split.data[[j]])
model <- glmer(MissedDose ~ Q7 + ZAlcTox + Day + Q7*Day + (1|PID), data = df, family=binomial(link=logit))
modbetas[[j]] <- summary(model)$coef[,1] # only take the coefficients of the variables, not the intercept
modse[[j]] <- summary(model)$coef[,2]
}
return(list(modbetas,modse))
}
set.seed(12345)
splitmods <- list()
for (i in 1:no.sim){
splitmods[i] <- list(mod.maker(split.data[[i]])) # fails to converge
}
set.seed(12345)
wavemods <- list()
for (i in 1:no.sim){
wavemods[i] <- list(mod.maker(wave.data[[i]])) # also fails to converge
}
splitmods[[1]]
mod.maker <- function(dat){ # passing split.data[[i]]
modbetas <- list()
modse <- list()
for (j in 1:length(dat)){
df <- data.frame(split.data[[j]])
model <- glmer(MissedDose ~ Q7 + ZAlcTox + Day + Q7*Day + (1|PID), data = df, family=binomial(link=logit))
modbetas[[j]] <- summary(model)$coef[,1] # only take the coefficients of the variables, not the intercept
modse[[j]] <- summary(model)$coef[,2]
}
return(list(betas=modbetas,se=modse))
}
set.seed(12345)
splitmods <- list()
for (i in 1:no.sim){
splitmods[i] <- list(mod.maker(split.data[[i]])) # fails to converge
}
splitmods[[1]]
for (i in 1:no.sim){
split.coeff.means[[i]] <- apply(do.call(rbind, splitmods[[i]]$betas),2,mean) # using split.coeff.means[[i]] throws an error about the subscript being out of bounds, but if run with split.coeff.means[i] and THEN double brackets, it works???
}
split.coeff.means
splitmods[[1]]
splitmods[[1]]$betas
do.call(rbind, splitmods[[i]]$betas)
apply(do.call(rbind, splitmods[[i]]$betas),2,mean)
for (i in 1:no.sim){
split.coeff.means[i] <- apply(do.call(rbind, splitmods[[i]]$betas),2,mean) # using split.coeff.means[[i]] throws an error about the subscript being out of bounds, but if run with split.coeff.means[i] and THEN double brackets, it works???
}
for (i in 1:no.sim){
split.coeff.means[[i]] <- apply(do.call(rbind, splitmods[[i]]$betas),2,mean) # using split.coeff.means[[i]] throws an error about the subscript being out of bounds, but if run with split.coeff.means[i] and THEN double brackets, it works???
}
split.coeff.means
splitmods[[1]]$betas
splitmods[[2]]$betas
for (i in 1:no.sim){
splitmods[[i]] <- list(mod.maker(split.data[[i]])) # fails to converge
}
splitmods
splitmods[[1]]
set.seed(12345)
wavemods <- list()
for (i in 1:no.sim){
wavemods[[i]] <- list(mod.maker(wave.data[[i]])) # also fails to converge
}
# Step 4 - Calculate mean parameter estimates for both methods
# compare means of coefficents overall and then find means of each person's intercept and compare those to original???
split.coeff.means <- list()
wave.coeff.means <- list()
for (i in 1:no.sim){
split.coeff.means[[i]] <- apply(do.call(rbind, splitmods[[i]]$betas),2,mean) # using split.coeff.means[[i]] throws an error about the subscript being out of bounds, but if run with split.coeff.means[i] and THEN double brackets, it works???
}
splitmods[[1]]$betas
splitmods[[1]]
splitmods$betas
splitmods[1]$betas
splitmods[[1]]
splitmods[[1]][[1]]
splitmods[[1]][1]
splitmods[[1]][1]
splitmods[[1]][1][1]
splitmods[[1]][[1]]$betas
splitmods <- list()
for (i in 1:no.sim){
splitmods[[i]] <- list(mod.maker(split.data[[i]])) # fails to converge
}
set.seed(12345)
wavemods <- list()
for (i in 1:no.sim){
wavemods[[i]] <- list(mod.maker(wave.data[[i]])) # also fails to converge
}
# Step 4 - Calculate mean parameter estimates for both methods
# compare means of coefficents overall and then find means of each person's intercept and compare those to original???
split.coeff.means <- list()
wave.coeff.means <- list()
for (i in 1:no.sim){
split.coeff.means[[i]] <- apply(do.call(rbind, splitmods[[i]]$betas),2,mean) # using split.coeff.means[[i]] throws an error about the subscript being out of bounds, but if run with split.coeff.means[i] and THEN double brackets, it works???
}
splitmods[[1]]
mod.maker <- function(dat){ # passing split.data[[i]]
modbetas <- list()
modse <- list()
for (j in 1:length(dat)){
df <- data.frame(split.data[[j]])
model <- glmer(MissedDose ~ Q7 + ZAlcTox + Day + Q7*Day + (1|PID), data = df, family=binomial(link=logit))
modbetas[[j]] <- summary(model)$coef[,1] # only take the coefficients of the variables, not the intercept
modse[[j]] <- summary(model)$coef[,2]
}
#return(list(betas=modbetas,se=modse))
return(list(modsbetas,modse))
}
splitmods <- list()
for (i in 1:no.sim){
splitmods[[i]]$betas <- mod.maker(split.data[[i]])[1] # fails to converge
splitmods[[i]]$se <- mod.maker(split.data[[i]])[2]
}
mod.maker <- function(dat){ # passing split.data[[i]]
modbetas <- list()
modse <- list()
for (j in 1:length(dat)){
df <- data.frame(split.data[[j]])
model <- glmer(MissedDose ~ Q7 + ZAlcTox + Day + Q7*Day + (1|PID), data = df, family=binomial(link=logit))
modbetas[[j]] <- summary(model)$coef[,1] # only take the coefficients of the variables, not the intercept
modse[[j]] <- summary(model)$coef[,2]
}
#return(list(betas=modbetas,se=modse))
return(list(modbetas,modse))
}
set.seed(12345)
splitmods <- list()
for (i in 1:no.sim){
splitmods[[i]]$betas <- mod.maker(split.data[[i]])[1] # fails to converge
splitmods[[i]]$se <- mod.maker(split.data[[i]])[2]
}
for (i in 1:no.sim){
splitmods[i]$betas <- mod.maker(split.data[[i]])[1] # fails to converge
splitmods[i]$se <- mod.maker(split.data[[i]])[2]
}
splitmods
for (i in 1:no.sim){
splitmods[i]$betas <- mod.maker(split.data[[i]])[1] # fails to converge
splitmods[i]$se <- mod.maker(split.data[[i]])[2]
}
for (i in 1:no.sim){
splitmods[[i]]$betas <- mod.maker(split.data[[i]])[[1]] # fails to converge
splitmods[[i]]$se <- mod.maker(split.data[[i]])[[2]]
}
# Install needed packages, if necessary
# install.packages(c('lme4','mvtnorm','lmerTest'))
# Set working directory
setwd("~/GitHub/designedmissingness/")
# Load necessary libraries
library(mice)
library(lme4)
library(mvtnorm)
library(lmerTest)
# Read in Daily With Tox CSV data file
Daily <- read.csv('~/GitHub/designedmissingness/Daily with Tox.csv')
# Retain desired variables
names(Daily)[1] <- c('PID')
Daily <- Daily[,c('PID', 'Day', 'Q1', 'Q2', 'Q3', 'Q4', 'Q5', 'Q6', 'Q7'
,'MissedDose'
, 'ZEduc', 'ZIncom45', 'Gender', 'Age', 'ZAlcTox'
,'ZCESDFU', 'ZAUDIT', 'DrinkYN')]
# Impute missing values in new dataset, 'comp'...Daily has 4.74% missing (sum(is.na(Daily))/prod(dim(Daily)))
comp <- complete(mice(Daily, m=1, seed=817236),1)
# Convert Age to data type 'double'
comp$Age <- as.numeric(comp$Age)
# Shift days back 1 day
comp$Day <- comp$Day-1
# Remove the Daily dataset from the environment
rm(Daily)
#comp$Age <- as.numeric(scale(comp$Age)) # why???
comp$Q1 <- as.factor(comp$Q1)
comp$Q2 <- as.factor(comp$Q2)
comp$Q3 <- as.factor(comp$Q3)
comp$Q4 <- as.factor(comp$Q4)
comp$Q5 <- as.factor(comp$Q5)
comp$Q6 <- as.factor(comp$Q6)
comp$Q7 <- as.factor(comp$DrinkYN)
comp$Q8 <- as.integer(comp$Q7)
comp$MissedDose <- as.factor(comp$MissedDose)
comp$Gender <- as.factor(comp$Gender)
cols.keep <- c('PID', 'Day', 'Q1', 'Q2', 'Q3', 'Q4', 'Q5', 'Q6', 'Q7', 'Q8', 'MissedDose', 'ZEduc', 'ZIncom45', 'Gender', 'Age', 'ZAlcTox', 'ZCESDFU', 'ZAUDIT')
comp <- comp[,cols.keep]
no.pid <- 60
pop.mod <- glmer(MissedDose ~ Q7 + ZAlcTox + Day + Q7*Day + (1|PID), data = comp, family=binomial(link=logit))
# pop.pids <- list()
pop.mod.coeffs <- summary(pop.mod)$coef[,1:2] # if glmer object: take the first row of coefficients, excluding the intercept, the betas are the same for each PID but the intercept varies.
# sim.pids <- list()
# sim.pid.means <- list()
#
# for (k in 1:no.pid){  # only 59 PIDs instead of 60...is it using PID = 1 as a baseline and that intercept is 0? the other PID list have 60...oh is that because we've simulated another person? I think this is the cause. Is that an issue? Maybe just don't compare results to the original population, just to their simulated parent data set?
#     pop.pids[[k]]<- coef(pop.mod)[[1]][[1]][k]
# }
# Correlation Matrix
# Use model.matrix to convert factor variables to dummy encoding
# Matches OG matrix!!!
corrmat <- cor(model.matrix(~.-1,data=comp[,c('ZEduc', 'ZIncom45', 'Age', 'ZAlcTox', 'ZCESDFU', 'ZAUDIT')]))
round(corrmat, 2) # display the matrix, rounding values to 2 decimal places
# Fit logistic models to each variable to use as foundation for simulation
# OG author built models that were seemingly random? New models are the target~all others
# Drink_fit <- glm(data=comp, DrinkYN~., family=binomial(link=logit)) # warning: fitted probs numerically 0 or 1 occurred
#
# Q1_fit <- glm(data=comp, Q1~., family=binomial(link=logit))
#
# Q2_fit <- glm(data=comp, Q2~., family=binomial(link=logit))
#
# Q3_fit <- glm(data=comp, Q3~., family=binomial(link=logit))
#
# Q4_fit <- glm(data=comp, Q4~., family=binomial(link=logit))
#
# Q5_fit <- glm(data=comp, Q5~., family=binomial(link=logit))
#
# Q6_fit <- glm(data=comp, Q6~., family=binomial(link=logit))
# OG stopped with Q6...but don't we want to simulate all of the variables? Nvm done with the corrmat
# Q7_fit <- lm(data=comp, Q7~.)
#
# MD_fit <- lm(data=comp, MissedDose~.)
#
# Edu_fit <- lm(data=comp, ZEduc~.)
#
# Inc_fit <- lm(data=comp, ZIncom45~.)
#
# Gender_fit <- lm(data=comp, Gender~.)
#
# Age_fit <- lm(data=comp, Q6~.)
#
# Alc_fit <- lm(data=comp, ZAlcTox~.)
#
# Cesdfu_fit <- lm(data=comp, ZCESDFU~.)
#
# Audit_fit <- lm(data=comp, ZAUDIT~.)
# for (n in names(comp[,-1])){
#   n <- as.name(n)
#   nam <- paste(n, "_fit", sep = "")
#   mod <- glm(data=comp,n~.-1,family=binomial(link=logit))
#   assign(nam, mod)
# }
# OG fit models for the questions using variables simulated via corrmat
fit1 <- glm(data=comp, Q7~ZIncom45+Age+ZAlcTox+ZAUDIT, family=binomial(link=logit))
fit2<- glm(data=comp, Q1~ZEduc+ZIncom45+ZAlcTox+ZCESDFU, family=binomial(link=logit))
fit3<- glm(data=comp, Q2~Q1+ZEduc+ZIncom45+Age+ZAlcTox+ZCESDFU+ZAUDIT+Gender, family=binomial(link=logit))
fit4<- glm(data=comp, Q3~Q1+Q2+ZEduc+ZIncom45+ZAlcTox+ZCESDFU+Gender, family=binomial(link=logit))
fit5<- glm(data=comp, Q4~Q1+Q2+Q3+ZEduc+ZAlcTox+ZCESDFU+ZAUDIT+Gender, family=binomial(link=logit))
fit6<- glm(data=comp, Q5~Q1+Q3+Q4+ZEduc+ZIncom45+ZAlcTox+ZAUDIT, family=binomial(link=logit))
fit7<- glm(data=comp, Q6~Q3+Q5+Q7+ZEduc+ZIncom45+Age+ZAlcTox+ZCESDFU+ZAUDIT, family=binomial(link=logit))
# Simulate
set.seed(1234)
no.sim = 5 # number of simulated datasets
sim.data <- list()
for (i in 1:no.sim) {
X <- as.data.frame(rmvnorm(60, mean=rep(0,6), sigma=corrmat))
names(X) <- c('ZEduc', 'ZIncom45', 'Age', 'ZAlcTox', 'ZCESDFU', 'ZAUDIT')
X$PID <- 1:60
X$Gender <- as.factor(rbinom(60, 1, prob=0.5))
X <- X[rep(row.names(X), 45),] #Repeat each row 45 times, all current variables are time invariant (ZAlcTox, too??)
X <- X[order(X$PID),] #Order by PID
X$Day <- rep(0:44, 60) #Create a variable containing day variable 0-44
# Create Variables
X$Q7 <- 1/(1+exp(-1*predict(fit1, newdata = X)))
X$Q7 <- as.factor(rbinom(2700, 1, prob = X$Q7))
X$Q1 <- 1/(1+exp(-1*predict(fit2, newdata=X)))
X$Q1 <- as.factor(rbinom(2700, 1, prob = X$Q1))
X$Q2 <- 1/(1+exp(-1*predict(fit3, newdata = X)))
X$Q2 <- as.factor(rbinom(2700,1,prob=X$Q2))
X$Q3 <- 1/(1+exp(-1*predict(fit4, newdata = X)))
X$Q3 <- as.factor(rbinom(2700,1,prob=X$Q3))
X$Q4 <- 1/(1+exp(-1*predict(fit5, newdata = X)))
X$Q4 <- as.factor(rbinom(2700,1,prob=X$Q4))
X$Q5 <- 1/(1+exp(-1*predict(fit6, newdata = X)))
X$Q5 <- as.factor(rbinom(2700,1,prob=X$Q5))
X$Q6 <- 1/(1+exp(-1*predict(fit7, newdata = X)))
X$Q6 <- as.factor(rbinom(2700,1,prob=X$Q6))
X$Q8 <- rpois(2700, 2) # lambda = 2...mean of 2. why???
X[X$Q7==0,c('Q8')] <- 0
# Make Missed Dose
# This is where issues come in!!!
# Closest I could get to these numbers was:
# MD <- glm(data=comp,MissedDose~ZEduc+ZIncom45+Age+ZAlcTox+ZCESDFU+ZAUDIT,family=binomial(link=logit))
# MD <- glm(data=comp,MissedDose~Q7+ZAlcTox+Day+Q7*Day,family=binomial(link=logit))
MD <- glmer(MissedDose ~ Q7 + ZAlcTox + Day + Q7*Day + (1|PID), data = comp, family=binomial(link=logit))
# Use a predict function instead of coding in the values
# int <- MD@beta[1]
# b1 <- MD@beta[2] # DrinkYN1
# b2 <- MD@beta[3] # Day
# b3 <- MD@beta[4] # ZAlcTox
# b4 <- MD@beta[5] # DrinkYN1:Day
sigmaPID <- MD@theta
X$groupErr <- rnorm(60, mean=0, sd=sigmaPID)[X$PID]
X$groupErr2 <- rnorm(60, mean=0, sd=sigmaPID)[X$PID]
X$MissedDose <- predict(MD,X,allow.new.levels=TRUE)
X$MissedDose <- 1/(1+exp(-X$MissedDose))
X$MissedDose <- rbinom(2700, 1, prob=X$MissedDose)
sim.data[[i]] <- X
}
sim.mods <- list()
sim.mod.intercepts <- list()
sim.mod.coeffs <- list()
for (i in 1:no.sim){
sim.mods[[i]] <- glmer(MissedDose ~ Q7 + ZAlcTox + Day + Q7*Day + (1|PID), data = as.data.frame(sim.data[i]), family=binomial(link=logit))
#sim.mod.intercepts[[i]] <- coef(sim.mods[[i]])[[1]][1]
sim.mod.coeffs[[i]] <- summary(sim.mods[[i]])$coef[,1:2] # take the first row and only the last 4 columns to get coefficients for everything but the intercepts
}
# sim.pids <- list()
# sim.pid.means <- list()
#
# for (k in 1:no.pid){
#   for (i in 1:no.sim){
#       sim.pids[[k]][[i]] <- sim.mod.intercepts[[i]][[1]][[1]][k] # subscripting thing and no. of items not multiple of replacement length warning
#   }
# }
#
# for (k in 1:no.pid){
#   sim.pid.means[k] <- mean(sim.pids[[k]])   # means for wave and split are very similar but not the same!
# }
#Remove unnecessary before analysis
rm(comp, sigma, X, b1, b2,b3,b4, fit1, fit2, fit3, fit4, fit5, fit6, fit7,
i, int, sigmaPID)
l1 <- sim.data[[1]]
## Create MISSINGNESS
# rremove <- function(nrem, x) { # this literally just randomly removes nrem columns. Like, the entire column. Why???
#   id <- sample(length(x), nrem)
#   x[id] <- NA
#   x
# }
grps <- list(X=c('Q1','Q8'),A=c('Q2','Q3'),B=c('Q4','Q5'),C=c('Q6','Q7'))
split.form <- function(set,grps){
set$block[sample(1:nrow(set),nrow(set),FALSE)] <- c('A','B','C')
set[set$block == "A",grps$A] <- NA
set[set$block == "B",grps$B] <- NA
set[set$block == "C",grps$C] <- NA
set
}
wave.des <- function(set, nmiss, ...) { # nmiss is the number of days each person would miss? 11?? Like, miss a fourth of the days?
id <- replicate(60, sample(2:44, size=nmiss))
for (i in 1:60) {
set[set$PID==i & set$Day %in% id[,i], c('Q1','Q2','Q3','Q4','Q5','Q6','Q7','Q8')] <- NA
}
set
}
# alt.split <- function(set,n,bound=0){
#   set[sample(set$Day <= bound,n),c('Q1','Q2','Q3','Q4','Q5','Q6','Q7')] <- t(apply(set[sample(set$Day <= bound,n),],split.form))
#   # above won't work, is applying split.form() to different sampled rows??
#   # maybe assign og sampled rows to variable and then apply split.form() to those and then reassign to set?
#
# }
# Step 1 - Apply PM methods to simulated datasets
set.seed(917236)
split.pm <- lapply(sim.data,function(x){split.form(x,grps)})
wave.pm <- lapply(sim.data,function(x){wave.des(x,11)})
no.imp = 5 # number of imputed datasets
# Step 2 - Impute simulated datasets, for both methods
split.imp <- lapply(split.pm, function(x) {mice(x, m=no.imp)}) # loop through the split.imps in the complete function
split.data <- list()
for (i in 1:no.sim){
split.data[[i]] <- list()
for (j in 1:no.imp){
split.data[[i]][[j]] <- complete(split.imp[[i]],j)
}
}
# s1 <- data.frame(split.data[1][1])
# s3 <- data.frame(split.data[3][1]) # very similar, but I guess that is obvious as the missingness isn't a lot
# w1 <- data.frame(wave.data[1][1])
wave.imp <- lapply(wave.pm, function(x) {mice(x, m=no.imp)})
wave.data <- list()
for (i in 1:no.sim){
wave.data[[i]] <- list()
for (j in 1:no.imp){
wave.data[[i]][[j]] <- complete(wave.imp[[i]],j)
}
}
mod.maker <- function(dat){ # passing split.data[[i]]
modbetas <- list()
modse <- list()
for (j in 1:length(dat)){
df <- data.frame(split.data[[j]])
model <- glmer(MissedDose ~ Q7 + ZAlcTox + Day + Q7*Day + (1|PID), data = df, family=binomial(link=logit))
modbetas[[j]] <- summary(model)$coef[,1] # only take the coefficients of the variables, not the intercept
modse[[j]] <- summary(model)$coef[,2]
}
#return(list(betas=modbetas,se=modse))
return(list(modbetas,modse))
}
set.seed(12345)
splitmods <- list()
for (i in 1:no.sim){
splitmods[[i]]$betas <- mod.maker(split.data[[i]])[[1]] # fails to converge
splitmods[[i]]$se <- mod.maker(split.data[[i]])[[2]]
}
mod.maker <- function(dat){ # passing split.data[[i]]
modbetas <- list()
modse <- list()
for (j in 1:length(dat)){
df <- data.frame(split.data[[j]])
model <- glmer(MissedDose ~ Q7 + ZAlcTox + Day + Q7*Day + (1|PID), data = df, family=binomial(link=logit))
modbetas[[j]] <- summary(model)$coef[,1] # only take the coefficients of the variables, not the intercept
modse[[j]] <- summary(model)$coef[,2]
}
return(list(betas=modbetas,se=modse))
}
set.seed(12345)
splitmods <- list()
for (i in 1:no.sim){
splitmods[[i]] <- list(mod.maker(split.data[[i]])) # fails to converge
}
splitmods
splitmods[[1]]$betas
for (i in 1:no.sim){
splitmods[i] <- list(mod.maker(split.data[[i]])) # fails to converge
}
splitmods[[1]]
splitmods[[1]]$betas
splitmods <- list()
for (i in 1:no.sim){
splitmods[i] <- list(mod.maker(split.data[[i]])) # fails to converge
}
splitmods[1]
splitmods[[1]]
set.seed(12345)
wavemods <- list()
for (i in 1:no.sim){
wavemods[i] <- list(mod.maker(wave.data[[i]])) # also fails to converge
}
# Step 4 - Calculate mean parameter estimates for both methods
# compare means of coefficents overall and then find means of each person's intercept and compare those to original???
split.coeff.means <- list()
wave.coeff.means <- list()
for (i in 1:no.sim){
split.coeff.means[[i]] <- apply(do.call(rbind, splitmods[[i]]$betas),2,mean) # using split.coeff.means[[i]] throws an error about the subscript being out of bounds, but if run with split.coeff.means[i] and THEN double brackets, it works???
}
split.coeff.means
for (i in 1:no.sim){
split.coeff.means[[i]] <- apply(do.call(rbind, splitmods[i]$betas),2,mean) # using split.coeff.means[[i]] throws an error about the subscript being out of bounds, but if run with split.coeff.means[i] and THEN double brackets, it works???
}
splitmods[[1]]$betas
for (i in 1:no.sim){
split.coeff.means[[i]] <- colMeans(do.call(rbind, splitmods[i]$betas)) # using split.coeff.means[[i]] throws an error about the subscript being out of bounds, but if run with split.coeff.means[i] and THEN double brackets, it works???
}
for (i in 1:no.sim){
split.coeff.means[[i]] <- colMeans(rbind(splitmods[i]$betas)) # using split.coeff.means[[i]] throws an error about the subscript being out of bounds, but if run with split.coeff.means[i] and THEN double brackets, it works???
}
rbind(splitmods[1]$betas)
splitmods[[1]]$betas
rbind(splitmods[[1]]$betas)
do.call(rbind,splitmods[[1]]$betas)
colMeans(do.call(rbind, splitmods[[i]]$betas))
colMeans(do.call(rbind, splitmods[[2]]$betas))
colMeans(do.call(rbind, splitmods[[1]]$betas))
do.call(rbind, splitmods[[2]]$betas)
do.call(rbind, splitmods[[3]]$betas)
